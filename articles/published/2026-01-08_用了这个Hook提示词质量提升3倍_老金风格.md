# 谷歌68页圣经看完更焦虑了，所以我做了个Hook

## 说个真事

谷歌那个68页的提示词圣经，大家都看了吧？

全是干货。

什么CTF公式、思维链、角色扮演、结构化输出...

看完我更焦虑了。

不是因为学不会，而是——

**谁能每次写提示词都按这个标准来？**

太累了。

---

## 昨天发文后的反馈

昨天发了《谷歌68页提示词圣经+老金原创元提示词》。

后台收到很多消息。

最多的一类是：

"老金，元提示词我收藏了，但每次用的时候还是懒得翻出来对照着写。"

"有没有更省事的方法？"

说实话，我也有这个问题。

写了5任务元提示词，自己用的时候也经常偷懒。

然后就在想：

**能不能让AI自动帮我按照元提示词的标准优化？**

我随便说两句大白话，AI自动翻译成符合圣经标准的专业提示词。

折腾了两天，还真搞出来了。

用的是Claude Code的Hook机制。

---

## 先放一下昨天的元提示词

没看过的先收藏，这是Hook的核心依据。

```markdown
# 老金的5任务元提示词 v1.0

这是一份实战行动清单，剔除了所有理论废话，直接告诉你怎么干。

## 任务一：构建提示词地基
目标：消除歧义，确保AI听懂人话。

[ ] 遵循CTF黄金公式
    - C (Context)：指定身份（如"资深CFO"而非"财务助手"）、受众、目标
    - T (Task)：使用强动词（分析、拆解、重写），量化要求（3个点、150字）
    - F (Format)：明确返回结构（Markdown表格、JSON、列表）

[ ] 区分System与User
    - System Prompt：写"宪法"（核心人设、底层规则、语言风格），保持不变
    - User Prompt：写"指令"（具体任务、输入数据），动态变化

[ ] 结构化输入
    - 使用分隔符（###, ---）或XML标签（<context>, <data>）隔离不同类型的信息
    - 防止AI混淆指令与内容

[ ] 采用肯定性指令
    - Do："请使用专业、客观的语气"
    - Don't："不要使用口语"（避免粉色大象效应）

## 任务二：激活深度推理
目标：让AI处理复杂逻辑，减少胡言乱语。

[ ] 策略选择决策树
    - 简单任务 → Zero-Shot（直接问）
    - 特定格式/风格 → Few-Shot（给1-3个完美范例）
    - 逻辑/数学题 → CoT（加一句"让我们一步步思考"）
    - 复杂决策 → ToT（让AI模拟三个专家辩论）
    - 抽象难题 → Step-Back（先问核心原理，再解决具体问题）

[ ] 强制自我修正
    - 在提示词中植入Review环节
    - "先生成草稿，再列出3个缺点，最后根据缺点生成修正版"

## 任务三：掌控回答与行为
目标：让AI的回答可控、机器可读、风格稳定。

[ ] 强制结构化回答
    - 提供Schema（如JSON键值对示例）
    - 使用Prefilling技巧：在API的assistant回复开头预填 { 或特定前缀

[ ] 调节参数
    - 0.0-0.2：清洗数据、提取事实、代码生成（严谨）
    - 0.7-1.0：创意写作、头脑风暴（发散）

[ ] 处理长文档
    - 指令后置：把核心指令放在Prompt的最后面（对抗"迷失中间"现象）
    - 主动检索：先让AI"提取所有相关原文引用"，再基于引用回答

## 任务四：架构自动化工作流
目标：解决单次Prompt搞不定的复杂项目。

[ ] 拒绝"超级提示词"
    - 不要试图用一段话搞定一切
    - 将任务拆解为流水线

[ ] 搭建提示词链
    - 搜集者AI（搜集信息）→ 分析师AI（处理数据）→ 作家AI（生成报告）
    - 每个环节只做一件事，上下文互不污染

[ ] 多智能体协作
    - 角色分解：PM、架构师、测试、开发
    - 上下文隔离：每个智能体在独立的对话窗口中运行

## 任务五：持续优化与维护
目标：把好用的提示词变成可复用的资产。

[ ] 版本管理
    - 记录：版本号、模型型号、参数、黄金回复样本
    - 像管理代码一样用Git管理提示词文件

[ ] A/B测试
    - 同样的任务，写2-3个不同的提示词
    - 跑10次，看哪个回复质量更稳定

[ ] 建立提示词库
    - 按场景分类：写作、分析、代码、翻译
    - 定期更新迭代
```

这就是昨天发的完整版，直接复制就能用。

---

## Hook是干嘛的

简单说：**提示词自动翻译器**。

你输入：随便说的大白话

Hook输出：符合谷歌圣经+元提示词标准的专业提示词

然后Claude收到的是优化后的版本。

---

## 先说清楚：这个Hook适合谁

**重要声明，别白折腾。**

这个Hook会在你发消息时自动优化提示词。

**会写提示词的人，别用。**

你本来就能写出高质量提示词，用这个Hook纯属浪费时间。

**不会写提示词的人，用了质量会好很多。**

你随便说两句，Hook帮你补全CTF公式、结构化输入、输出格式...

Claude收到的是专业级提示词，输出质量自然上去了。

---

## 举个例子

你说：\"做个登录\"

Hook自动翻译成：

```markdown
📝 **原始输入**：做个登录

🔄 **优化后的理解**：
- **Context（上下文）**：Web应用，资深全栈工程师，生产级安全要求
- **Task（任务）**：实现完整的用户登录功能，包括前端表单、后端验证、token生成、会话管理
- **Format（格式）**：完整代码文件 + 关键逻辑注释 + 测试用例

✅ **优化后的完整提示词**：

**任务**：实现用户登录功能

**上下文**：
- 身份：资深全栈工程师
- 技术栈：React + TypeScript + Node.js
- 安全要求：生产级别

**具体要求**：
1. 使用JWT做token认证
2. 密码用bcrypt加密存储
3. 登录失败3次锁定账号10分钟
4. 成功后返回用户信息和token

**输出格式**：
- 完整的前后端代码文件
- 关键逻辑注释
- 安全最佳实践说明（防SQL注入、XSS）
- 测试用例
```

Claude收到这个，直接开干。

不用来回问"用什么框架？""要不要加验证？"

---

## Hook的核心提示词

这是我基于5任务元提示词写的优化提示词：

```markdown
你是一个提示词优化专家，精通谷歌提示词圣经和老金5任务元提示词。

用户会给你一段简短的需求描述。

你的任务是把它优化成符合最佳实践的专业提示词。

优化原则（基于5任务元提示词）：

【任务一：构建地基】
1. 应用CTF公式：补充Context（身份、受众、目标）、Task（强动词+量化）、Format（输出结构）
2. 区分指令与内容，使用分隔符或XML标签
3. 采用肯定性指令，避免"不要"

【任务二：激活推理】
4. 根据任务复杂度选择策略：简单用Zero-Shot，需要格式用Few-Shot，逻辑题用CoT
5. 复杂任务加入自我修正环节

【任务三：掌控输出】
6. 明确输出格式和验收标准
7. 添加边界条件和异常处理要求

输出格式：
必须按照以下格式输出：

📝 **原始输入**：[用户原话]
🔄 **优化后的理解**：
   - Context: [推断信息]
   - Task: [明确动作]
   - Format: [输出形式]
✅ **优化后的完整提示词**：[详细版]
```

核心思路：

**把5任务元提示词的规则，变成AI自动执行的检查清单。**

你只管说大概意思，AI帮你补全所有该有的细节。

---

## 怎么配置这个Hook

Hook的工作原理：

在你发消息给Claude时，Hook会拦截并优化你的提示词，然后把优化后的版本发给Claude。

### 第一步：创建Hook脚本

在项目的 `.claude/hooks/` 目录下创建 `user-prompt-submit.sh`：

```bash
#!/bin/bash

# 读取用户输入
USER_INPUT="$*"
if [ -z "$USER_INPUT" ]; then
    USER_INPUT=$(cat)
fi

# 智能过滤：简短问题不优化（<30字）
INPUT_LENGTH=${#USER_INPUT}
if [ "$INPUT_LENGTH" -lt 10 ]; then
    echo "$USER_INPUT"
    exit 0
fi

# 简单回复不优化
case "$USER_INPUT" in
    好的|是的|继续|谢谢|ok|yes|no|确认|取消)
        echo "$USER_INPUT"
        exit 0
        ;;
esac

# 读取优化提示词模板
OPTIMIZER_PROMPT=$(cat ".claude/prompt-optimizer-meta.md")

# 构建优化请求
OPTIMIZATION_REQUEST="$OPTIMIZER_PROMPT

---

用户原始输入：$USER_INPUT

---

请严格按照格式输出优化结果。"

# 输出优化请求
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "🔄 提示词自动优化中..."
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo ""
echo "$OPTIMIZATION_REQUEST"
echo ""
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "✅ 优化完成，自动继续执行..."
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
```

给脚本添加执行权限：

```bash
chmod +x .claude/hooks/user-prompt-submit.sh
```

### 第二步：配置Hook

在 `.claude/settings.json` 中添加Hook配置：

```json
{
  "hooks": {
    "user-prompt-submit": {
      "enabled": true,
      "command": "bash",
      "args": [".claude/hooks/user-prompt-submit.sh"]
    }
  }
}
```

### 第三步：创建优化提示词模板

在 `.claude/prompt-optimizer-meta.md` 中放入上面的优化提示词。

### Gemini是可选的

**默认情况**：Hook会让当前Claude模型自己优化（零额外成本）

**想用Gemini**：可以配置Gemini MCP服务器（免费，速度更快）

在 `~/.claude/mcp.json` 添加：

```json
{
  "mcpServers": {
    "gemini-nanobanana-mcp": {
      "command": "npx",
      "args": ["-y", "@nanobanana/gemini-mcp"],
      "env": {
        "GEMINI_API_KEY": "你的API Key"
      }
    }
  }
}
```

Gemini API Key免费申请：https://aistudio.google.com/

---

## 工作流程

```
1. 你输入："做个登录"
   ↓
2. Hook拦截
   ↓
3. 显示：━━━━ 提示词自动优化中... ━━━━
   ↓
4. 输出优化后的提示词：
   📝 原始输入：做个登录
   🔄 优化后的理解：...
   ✅ 优化后的完整提示词：...
   ↓
5. 显示：━━━━ 优化完成，自动继续执行... ━━━━
   ↓
6. Claude收到优化后的版本并执行
```

**你能看到完整的优化过程，然后自动继续！**

---

## 实测3个场景

用了几天，测了几个典型场景。

**场景1：快速原型**

输入："做个聊天界面"

优化后：

```markdown
📝 **原始输入**：做个聊天界面

🔄 **优化后的理解**：
- **Context**：资深前端工程师，React + TypeScript
- **Task**：创建完整的聊天界面组件，包括布局、消息显示、发送功能
- **Format**：完整组件代码 + CSS样式 + 使用示例

✅ **优化后的完整提示词**：

**任务**：创建聊天界面组件

**具体要求**：
1. 布局：左侧联系人列表，右侧聊天窗口
2. 功能：发送文字、显示消息、自动滚动到底部
3. 样式：气泡消息，区分发送/接收
4. 状态：当前选中联系人、消息列表
5. 响应式：移动端单栏，桌面端双栏

**输出格式**：
- 完整组件代码
- CSS样式
- 使用示例
```

Claude收到这个，半小时就搞定了完整界面。

**场景2：Debug**

输入："这个报错怎么回事"

优化后：

```markdown
📝 **原始输入**：这个报错怎么回事

🔄 **优化后的理解**：
- **Context**：遇到代码错误，需要Debug专家分析
- **Task**：定位错误根因并提供修复方案
- **Format**：问题原因 + 修复代码 + 预防建议

✅ **优化后的完整提示词**：

**任务**：分析并修复错误

**分析步骤**：
1. 阅读错误堆栈，定位问题代码位置
2. 分析可能原因（类型错误/空值/逻辑错误）
3. 检查相关上下文代码

**输出要求**：
- 问题原因（一句话）
- 修复方案（代码）
- 防止再次发生的建议

**自我检查**：
修复后确认类型安全，不引入新问题
```

Claude会系统地分析问题，不会只给一个简单答案。

**场景3：重构**

输入："这段代码太乱了"

优化后会补充完整的重构规范和验收标准。

---

## 踩过的坑

用了几天，有几个问题必须说。

**坑1：有时候过度优化**

简单问题会被优化得太复杂。

比如你只想问"这个变量是什么意思"。

被优化成要分析整个代码结构。

解决办法：加个长度判断，短问题不优化。

**坑2：需要适应新流程**

一开始不习惯看到优化过程。

但用几次就会发现，看到优化过程能学到很多。

知道什么样的提示词才算"好"。

---

## 这个Hook的本质

说到底，这个Hook做的事情很简单：

**把谷歌68页圣经+5任务元提示词的规则，变成自动执行的流程。**

你不用记住所有规则。

你不用每次都检查CTF公式有没有写全。

你不用纠结该用Zero-Shot还是CoT。

Hook帮你全干了。

这就是为什么我说：

**看完圣经更焦虑，是因为你想靠人脑执行。**

**把规则交给AI执行，焦虑就没了。**

---

## 写在最后

昨天发的元提示词是"方法论"。

今天这个Hook是"自动化工具"。

两个结合起来用，效果翻倍。

核心思路：

**把你学到的规则，变成AI自动执行的流程。**

这个思路，比任何具体工具都重要。

---

如果对你有帮助，记得关注一波~

---

**引用来源（供验证）**

- Google提示词圣经：Gemini for Google Workspace Prompt Guide https://inthecloud.withgoogle.com/gemini-for-google-workspace-prompt-guide/dl-cd.html
- Claude Code Hooks文档：官方Hook机制说明 https://docs.anthropic.com/en/docs/claude-code/hooks
- Gemini API：免费申请地址 https://aistudio.google.com/
